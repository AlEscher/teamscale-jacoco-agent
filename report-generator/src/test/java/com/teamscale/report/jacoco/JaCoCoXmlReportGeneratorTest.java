package com.teamscale.report.jacoco;

import com.teamscale.report.EDuplicateClassFileBehavior;
import com.teamscale.report.jacoco.dump.Dump;
import com.teamscale.report.util.ClasspathWildcardIncludeFilter;
import com.teamscale.report.util.ILogger;
import com.teamscale.test.TestDataBase;
import org.jacoco.core.data.ExecutionData;
import org.jacoco.core.data.ExecutionDataStore;
import org.jacoco.core.data.SessionInfo;
import org.jacoco.core.internal.data.CRC64;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.mock;

/** Tests report generation with and without duplicate classes. */
public class JaCoCoXmlReportGeneratorTest extends TestDataBase {

	/** Ensures that the normal case (no duplicated classes) runs without exceptions. */
	@Test
	void testNormalCaseThrowsNoException() throws Exception {
		try {
			runGenerator("no-duplicates", EDuplicateClassFileBehavior.FAIL);
		} catch (EmptyReportException e) {
			// An empty report exception is thrown here because we did not configure the correct class IDs to match the
			// artificial coverage generated by createDummyDump to the actual class file. Since we are only testing for
			// IllegalStateExceptions resulting from duplicated, non-identical class files, and don't care about empty
			// reports here. Therefore we catch this exception to avoid letting the test fail because of it.
		}
	}

	/** Ensures that two identical duplicate classes do not cause problems. */
	@Test
	void testIdenticalClassesShouldNotThrowException() throws Exception {
		try {
			runGenerator("identical-duplicate-classes", EDuplicateClassFileBehavior.FAIL);
		} catch (EmptyReportException e) {
			// An empty report exception is thrown here because we did not configure the correct class IDs to match the
			// artificial coverage generated by createDummyDump to the actual class file. Since we are only testing for
			// IllegalStateExceptions resulting from duplicated, non-identical class files, and don't care about empty
			// reports here. Therefore we catch this exception to avoid letting the test fail because of it.
		}
	}

	/**
	 * Ensures that two non-identical, duplicate classes cause an exception to be thrown.
	 */
	@Test
	void testDifferentClassesWithTheSameNameShouldThrowException() {
		assertThatThrownBy(() -> runGenerator("different-duplicate-classes", EDuplicateClassFileBehavior.FAIL))
				.isExactlyInstanceOf(IOException.class).hasCauseExactlyInstanceOf(IllegalStateException.class);
	}

	/**
	 * Ensures that two non-identical, duplicate classes do not cause an exception to be thrown if the ignore-duplicates
	 * flag is set.
	 */
	@Test
	void testDifferentClassesWithTheSameNameShouldNotThrowExceptionIfFlagIsSet() throws Exception {
		try {
			runGenerator("different-duplicate-classes", EDuplicateClassFileBehavior.IGNORE);
		} catch (EmptyReportException e) {
			// An empty report exception is thrown here because we did not configure the correct class IDs to match the
			// artificial coverage generated by createDummyDump to the actual class file. Since we are only testing for
			// IllegalStateExceptions resulting from duplicated, non-identical class files, and don't care about empty
			// reports here. Therefore we catch this exception to avoid letting the test fail because of it.
		}
	}

	@Test
	void testEmptyCoverageFileThrowsException() throws IOException {
		String testFolderName = "empty-report-handling";
		long classId = calculateClassId(testFolderName, "TestClass.class");
		assertThatThrownBy(() -> runGenerator(testFolderName, EDuplicateClassFileBehavior.IGNORE, false,
				new ClasspathWildcardIncludeFilter("some.package.*", null), createDummyDump(classId)))
				.isExactlyInstanceOf(EmptyReportException.class);
	}

	@Test
	void testNonEmptyCoverageFileDoesNotThrowException() throws IOException, EmptyReportException {
		String testFolderName = "empty-report-handling";
		long classId = calculateClassId(testFolderName, "TestClass.class");
		runGenerator(testFolderName, EDuplicateClassFileBehavior.IGNORE, false,
				new ClasspathWildcardIncludeFilter("*", null), createDummyDump(classId));
	}
	
	/** Ensures that uncovered classes are removed from the report if ignore-uncovered-classes is set. */
	@Test
	void testShrinking() throws Exception {
		String testFolderName = "ignore-uncovered-classes";
		long classId = calculateClassId(testFolderName, "TestClass.class");
		ByteArrayOutputStream stream = new ByteArrayOutputStream();

		runGenerator(testFolderName, EDuplicateClassFileBehavior.FAIL, true,
				new ClasspathWildcardIncludeFilter("*", null),
				createDummyDump(classId)).copy(stream);

		String xmlString = stream.toString(StandardCharsets.UTF_8.name());
		assertThat(xmlString).contains("TestClass");
		assertThat(xmlString).doesNotContain("TestClassTwo");
	}
	
	/** Ensures that uncovered classes are contained in the report if ignore-uncovered-classes is not set. */
	@Test
	void testNonShrinking() throws Exception {
		String testFolderName = "ignore-uncovered-classes";
		long classId = calculateClassId(testFolderName, "TestClass.class");
		ByteArrayOutputStream stream = new ByteArrayOutputStream();

		runGenerator(testFolderName, EDuplicateClassFileBehavior.FAIL, false,
				new ClasspathWildcardIncludeFilter("*", null),
				createDummyDump(classId)).copy(stream);

		String xmlString = stream.toString(StandardCharsets.UTF_8.name());
		assertThat(xmlString).contains("TestClassTwo");
	}

	/**
	 * Creates a dummy dump with the specified class ID. The class ID can currently be calculated with {@link
	 * org.jacoco.core.internal.data.CRC64#classId(byte[])}. This might change in the future, as it's considered an
	 * implementation detail of JaCoCo (c.f. <a href="https://www.jacoco.org/jacoco/trunk/doc/classids.html">
	 * https://www.jacoco.org/jacoco/trunk/doc/classids.html</a>)
	 */
	private static Dump createDummyDump(long classId) {
		ExecutionDataStore store = new ExecutionDataStore();
		store.put(new ExecutionData(classId, "TestClass", new boolean[]{true, true, true}));
		SessionInfo info = new SessionInfo("session-id", 124L, 125L);
		return new Dump(info, store);
	}

	/** Creates a dummy dump with an arbitrary class ID. */
	private static Dump createDummyDump() {
		return createDummyDump(123);
	}

	private long calculateClassId(String testFolderName, String classFileName) throws IOException {
		File classFile = useTestFile(testFolderName + File.separator + classFileName);
		return CRC64.classId(Files.readAllBytes(classFile.toPath()));
	}

	/** Runs the report generator with default values and without ignoring uncovered classes. */
	private CoverageFile runGenerator(String testDataFolder,
							  EDuplicateClassFileBehavior duplicateClassFileBehavior) throws Exception, EmptyReportException {
		return runGenerator(testDataFolder, duplicateClassFileBehavior, false, new ClasspathWildcardIncludeFilter(null, null),
				createDummyDump());
	}

	private CoverageFile runGenerator(String testDataFolder,
							  EDuplicateClassFileBehavior duplicateClassFileBehavior, boolean ignoreUncoveredClasses,
							  ClasspathWildcardIncludeFilter filter,
							  Dump dump) throws IOException, EmptyReportException {
		File classFileFolder = useTestFile(testDataFolder);
		long currentTime = System.currentTimeMillis();
		String outputFilePath = "test-coverage-" + currentTime + ".xml";
		return new JaCoCoXmlReportGenerator(Collections.singletonList(classFileFolder), filter,
				duplicateClassFileBehavior, ignoreUncoveredClasses,
				mock(ILogger.class)).convert(dump, Paths.get(outputFilePath).toFile());
	}
}
